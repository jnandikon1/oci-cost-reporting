#!/usr/bin/env python3
"""
Ansible-managed Database Loader Template
Load OCI inventory CSV data to Autonomous Data Warehouse
Generated by Ansible at {{ ansible_date_time.iso8601 }}
"""

import cx_Oracle
import pandas as pd
from pathlib import Path
from datetime import datetime
import logging
import os
from typing import Optional, Dict

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Configuration from Ansible variables
BASE_DIR = Path('{{ project_base_dir }}')
DATA_DIR = BASE_DIR / 'data'
LOGS_DIR = BASE_DIR / 'logs'
LOGS_DIR.mkdir(exist_ok=True)

# ADW Configuration
ADW_WALLET_PATH = '{{ adw_wallet_path }}'
ADW_USER = '{{ adw_user }}'
ADW_PASSWORD = '{{ adw_password }}'
ADW_CONNECTION_NAME = '{{ adw_connection_name }}'


class ADWLoader:
    """Manage ADW connections and data loading operations."""

    def __init__(self, wallet_path: str, user: str, connection_name: str):
        """Initialize ADW connection with wallet."""
        self.wallet_path = wallet_path
        self.user = user
        self.connection_name = connection_name
        self.connection = None

    def connect(self, password: str) -> bool:
        """Establish connection to ADW."""
        try:
            cx_Oracle.init_oracle_client(lib_dir="/usr/lib/oracle/current/client64/lib")

            dsn = cx_Oracle.makedsn(
                self.connection_name,
                1522,
                service_name=self.connection_name
            )

            self.connection = cx_Oracle.connect(
                self.user,
                password,
                dsn,
                encoding="UTF-8"
            )
            logger.info(f"Connected to ADW: {self.connection_name}")
            return True

        except Exception as e:
            logger.error(f"Failed to connect to ADW: {str(e)}")
            return False

    def disconnect(self):
        """Close ADW connection."""
        if self.connection:
            self.connection.close()
            logger.info("ADW connection closed")

    def create_adb_inventory_table(self):
        """Create ADB inventory table if not exists."""
        query = """
        CREATE TABLE IF NOT EXISTS OCI_ADB_INVENTORY (
            ID NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
            COMPARTMENT_NAME VARCHAR2(256),
            COMPARTMENT_OCID VARCHAR2(256),
            ADB_NAME VARCHAR2(256),
            ADB_OCID VARCHAR2(256),
            ADB_TYPE VARCHAR2(50),
            LIFECYCLE_STATE VARCHAR2(50),
            CPU_COUNT NUMBER,
            STORAGE_TB NUMBER,
            AUTO_SCALING VARCHAR2(10),
            LICENSE_MODEL VARCHAR2(50),
            TIME_CREATED TIMESTAMP,
            LOADED_AT TIMESTAMP DEFAULT SYSDATE,
            UNIQUE(ADB_OCID, LOADED_AT)
        )
        """
        try:
            cursor = self.connection.cursor()
            cursor.execute(query)
            self.connection.commit()
            logger.info("ADB inventory table created/verified")
        except Exception as e:
            logger.warning(f"Table creation note: {str(e)}")

    def create_non_adb_inventory_table(self):
        """Create Non-ADB infrastructure inventory table if not exists."""
        query = """
        CREATE TABLE IF NOT EXISTS OCI_NON_ADB_INVENTORY (
            ID NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
            COMPARTMENT VARCHAR2(256),
            RESOURCE_TYPE VARCHAR2(50),
            RESOURCE_NAME VARCHAR2(256),
            RESOURCE_OCID VARCHAR2(256),
            CPU_COUNT NUMBER,
            LIFECYCLE_STATE VARCHAR2(50),
            LOADED_AT TIMESTAMP DEFAULT SYSDATE,
            UNIQUE(RESOURCE_OCID, LOADED_AT)
        )
        """
        try:
            cursor = self.connection.cursor()
            cursor.execute(query)
            self.connection.commit()
            logger.info("Non-ADB inventory table created/verified")
        except Exception as e:
            logger.warning(f"Table creation note: {str(e)}")

    def load_adb_inventory(self, csv_file: Path) -> int:
        """Load ADB inventory CSV into ADW."""
        try:
            df = pd.read_csv(csv_file)
            cursor = self.connection.cursor()

            insert_query = """
            INSERT INTO OCI_ADB_INVENTORY (
                COMPARTMENT_NAME, COMPARTMENT_OCID, ADB_NAME, ADB_OCID,
                ADB_TYPE, LIFECYCLE_STATE, CPU_COUNT, STORAGE_TB,
                AUTO_SCALING, LICENSE_MODEL, TIME_CREATED
            ) VALUES (:1, :2, :3, :4, :5, :6, :7, :8, :9, :10, :11)
            """

            rows_inserted = 0
            for _, row in df.iterrows():
                try:
                    cursor.execute(insert_query, (
                        row.get('Compartment_Name'),
                        row.get('Compartment_OCID'),
                        row.get('ADB_Name'),
                        row.get('ADB_OCID'),
                        row.get('ADB_Type'),
                        row.get('Lifecycle_State'),
                        float(row.get('CPU_Count', 0)) if pd.notna(row.get('CPU_Count')) else None,
                        float(row.get('Storage_TB', 0)) if pd.notna(row.get('Storage_TB')) else None,
                        row.get('Auto_Scaling'),
                        row.get('License_Model'),
                        row.get('Time_Created')
                    ))
                    rows_inserted += 1
                except Exception as e:
                    logger.warning(f"Failed to insert row: {str(e)}")
                    continue

            self.connection.commit()
            logger.info(f"Loaded {rows_inserted} ADB inventory rows from {csv_file.name}")
            return rows_inserted

        except Exception as e:
            logger.error(f"Failed to load ADB inventory: {str(e)}")
            return 0

    def load_non_adb_inventory(self, csv_file: Path) -> int:
        """Load Non-ADB inventory CSV into ADW."""
        try:
            df = pd.read_csv(csv_file)
            cursor = self.connection.cursor()

            insert_query = """
            INSERT INTO OCI_NON_ADB_INVENTORY (
                COMPARTMENT, RESOURCE_TYPE, RESOURCE_NAME, RESOURCE_OCID,
                CPU_COUNT, LIFECYCLE_STATE
            ) VALUES (:1, :2, :3, :4, :5, :6)
            """

            rows_inserted = 0
            for _, row in df.iterrows():
                try:
                    cursor.execute(insert_query, (
                        row.get('Compartment'),
                        row.get('Resource_Type'),
                        row.get('Name'),
                        row.get('OCID'),
                        float(row.get('CPU_Count', 0)) if pd.notna(row.get('CPU_Count')) else None,
                        row.get('Lifecycle_State')
                    ))
                    rows_inserted += 1
                except Exception as e:
                    logger.warning(f"Failed to insert row: {str(e)}")
                    continue

            self.connection.commit()
            logger.info(f"Loaded {rows_inserted} Non-ADB inventory rows from {csv_file.name}")
            return rows_inserted

        except Exception as e:
            logger.error(f"Failed to load Non-ADB inventory: {str(e)}")
            return 0


def load_latest_inventories(password: str) -> Dict[str, int]:
    """Load latest CSV inventories to ADW."""
    loader = ADWLoader(ADW_WALLET_PATH, ADW_USER, ADW_CONNECTION_NAME)

    if not loader.connect(password):
        return {"status": "error", "message": "Failed to connect to ADW"}

    results = {"adb_rows": 0, "non_adb_rows": 0}

    try:
        # Create tables
        loader.create_adb_inventory_table()
        loader.create_non_adb_inventory_table()

        # Load latest ADB inventory
        adb_files = sorted(DATA_DIR.glob("adb_inventory_*.csv"), reverse=True)
        if adb_files:
            results["adb_rows"] = loader.load_adb_inventory(adb_files[0])

        # Load latest Non-ADB inventory
        non_adb_files = sorted(DATA_DIR.glob("non_adb_infra_inventory_*.csv"), reverse=True)
        if non_adb_files:
            results["non_adb_rows"] = loader.load_non_adb_inventory(non_adb_files[0])

        results["status"] = "success"
        logger.info(f"Inventory load completed: {results}")

    finally:
        loader.disconnect()

    return results


if __name__ == "__main__":
    results = load_latest_inventories(ADW_PASSWORD)
    print(f"\n{results}")
